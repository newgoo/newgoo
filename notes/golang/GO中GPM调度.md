GO中GPM调度
---
#### 举例
```go
package main

import "time"

func main() {
	for i := 0; i < 2; i++ {
		go g() //创建了g1,g2
	}
	<-time.Tick(time.Hour)
}

func g() {}
```
main.main函数创建了两个G(g1,g2)，这两个G会被放入到系统的P队列(默认2048)中去，如果队列满了，就会被放入到全局列表去，等待其他M/P调度，当调度到g1的时候，运行的M就会将相关的寄存器地址指向这个G的内部进行操作，操作的内存申请等会被放入这个G自己的栈中，相关的管理操作会切到`g0`去操作;

`ps:g0是在M生成的时候就会生成一个g0的G`

#### 说明
* P(processor)：控制并发的数量，每一个G必须绑定有效的P才能执行，否则的话就会休眠，直到有空闲的P，P还为G提供执行资源，包括分配对象、本地任务队列，每个G独享P的资源，所以是无锁，也是GO能这么高效的原因; 

    * 在给P增加G的过程中，如果P的队列已经满了，则会将一半的G放入到全局队列中，用以其他P/M调用(全局队列中是有锁的)
    
* G(Goroutines)：初始化为2k,保存goruntime的运行状态(包括与P的绑定状态)，和为运行提供所需要的栈空间，当G运行完成后会被放入P的复用队列;

    * G的状态:idle(新建)->dead(初始化完成)->runnable(可执行)->running->gfree
    * G在绑定P的过程中如果没有指定P，则会尝试获取空闲P(自旋技术累加，避免唤醒多个P)，再去获取M(休眠中没有就会新建)，再去唤醒M执行P队列中的G

* M：G的实际执行体，和每一个内核线程一一对应，由四个方法循环执行(schedule,excute,goruntime fn,goexit),在执行的过程中，M直接指向G的栈内存，并且分配资源等也是在这个G里面，当需要切换时，只需要将M执行的相关寄存器地址直接指向需要执行的地方就行，也可以因此将某一个G恢复执行;
    * M只负责执行，不持有状态，这也是多路复用让GO能实现这么高并发的原因
    * 当M被唤醒，则会去各个地方获取G执行，只有当M用时过长，或者是系统阻塞，被剥夺P时候，M才会再次进入休眠状态

* 当当前G执行完成后，会从任务队列中获取新的G，如果队列中的可执行G已经用完，会去全局G队列取一组在本地执行，如果全局G队列都没了，就会在其他P里面去截取一组的G;

* P/M 本身是一一对应的关系，但是当M由于收到系统调用长时间阻塞，P会被监视线程抢回，去新建一个M去执行这个被强占了的P的其他任务

#### 抢占调度
* 只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占
* Go程序的初始化过程中，runtime开了一条后台线程，运行一个sysmon函数。这个函数会周期性地做epoll操作，同时它还会检测每个P是否运行了较长时间。
* 如果检测到某个P状态处于Psyscall(系统调用)超过了一个sysmon的时间周期(20us)，并且还有其它可运行的任务，则切换P。
* 如果检测到某个P的状态为Prunning，并且它已经运行了超过10ms，则会将P的当前的G的stackguard设置为StackPreempt。这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。
* 由于golang是采用分段栈，所以golang的枪战调度是在每个函数入口处比较当前的栈寄存器值和stackguard值来决定是否触发morestack函数，也就是被抢占，这也是有一个问题

`ps：如果一个goroutine运行了很久，但是它并没有调用另一个函数，则它不会被抢占。`